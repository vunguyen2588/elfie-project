/* eslint-disable no-eval, @babel/new-cap */
import path from 'path';
import fs from 'fs';
import { queries as baseQueries, } from '@testing-library/dom';
import 'simmerjs';
const DOM_TESTING_LIBRARY_UMD_PATH = path.join(require.resolve('@testing-library/dom'), '../../', 'dist/@testing-library/dom.umd.js');
const DOM_TESTING_LIBRARY_UMD = fs
    .readFileSync(DOM_TESTING_LIBRARY_UMD_PATH)
    .toString()
    .replace('define.amd', 'false'); // Never inject DTL using AMD define function
const SIMMERJS = fs
    .readFileSync(require.resolve('simmerjs/dist/simmer.js'))
    .toString();
let _config;
function isContainerWithExecute(container) {
    return container.execute != null;
}
function findContainerWithExecute(container) {
    let curContainer = container.parent;
    while (!isContainerWithExecute(curContainer)) {
        curContainer = curContainer.parent;
    }
    return curContainer;
}
async function injectDOMTestingLibrary(container) {
    const containerWithExecute = findContainerWithExecute(container);
    const shouldInject = await containerWithExecute.execute(function () {
        return {
            domTestingLibrary: !window.TestingLibraryDom,
            simmer: !window.Simmer,
        };
    });
    if (shouldInject.domTestingLibrary) {
        await containerWithExecute.execute(function (library) {
            // add DOM Testing Library to page as a script tag to support Firefox
            if (navigator.userAgent.includes('Firefox')) {
                const script = document.createElement('script');
                script.innerHTML = library;
                return document.head.append(script);
            }
            // eval library on other browsers
            return eval(library);
        }, DOM_TESTING_LIBRARY_UMD);
    }
    if (shouldInject.simmer) {
        await containerWithExecute.execute(SIMMERJS);
    }
    await containerWithExecute.execute(function (config) {
        window.TestingLibraryDom.configure(config);
    }, _config);
}
function serializeObject(object) {
    return Object.entries(object)
        .map(([key, value]) => [
        key,
        serializeArg(value),
    ])
        .reduce((acc, [key, value]) => ({ ...acc, [key]: value }), {
        serialized: 'object',
    });
}
function serializeArg(arg) {
    if (arg instanceof RegExp) {
        return { serialized: 'RegExp', RegExp: arg.toString() };
    }
    if (typeof arg === 'undefined') {
        return { serialized: 'Undefined', Undefined: true };
    }
    if (arg && typeof arg === 'object') {
        return serializeObject(arg);
    }
    return arg;
}
function executeQuery(query, container, ...args) {
    const done = args.pop();
    function deserializeObject(object) {
        return Object.entries(object)
            .map(([key, value]) => [key, deserializeArg(value)])
            .reduce((acc, [key, value]) => ({ ...acc, [key]: value }), {});
    }
    function deserializeArg(arg) {
        if (typeof arg === 'object' && arg.serialized === 'RegExp') {
            return eval(arg.RegExp);
        }
        if (typeof arg === 'object' && arg.serialized === 'Undefined') {
            return undefined;
        }
        if (typeof arg === 'object') {
            return deserializeObject(arg);
        }
        return arg;
    }
    const [matcher, options, waitForOptions] = args.map(deserializeArg);
    void (async () => {
        let result = null;
        try {
            // Override RegExp to fix 'matcher instanceof RegExp' check on Firefox
            window.RegExp = RegExp;
            result = await window.TestingLibraryDom[query](container, matcher, options, waitForOptions);
        }
        catch (e) {
            return done(e.message);
        }
        if (!result) {
            return done(null);
        }
        function makeSelectorResult(element) {
            // use simmer if possible to allow element refetching by position, otherwise
            // situations such as a React key change causes refetching to fail.
            const selector = window.Simmer(element);
            if (selector)
                return { selector };
            // use generated element id as selector if Simmer fails
            const elementIdAttributeName = 'data-wdio-testing-lib-element-id';
            let elementId = element.getAttribute(elementIdAttributeName);
            // if id doesn't already exist create one and add it to element
            if (!elementId) {
                elementId = (Math.abs(Math.random()) * 1000000000000).toFixed(0);
                element.setAttribute(elementIdAttributeName, elementId);
            }
            return { selector: `[${elementIdAttributeName}="${elementId}"]` };
        }
        if (Array.isArray(result)) {
            return done(result.map(makeSelectorResult));
        }
        return done(makeSelectorResult(result));
    })();
}
function createQuery(container, queryName) {
    return async (...args) => {
        await injectDOMTestingLibrary(container);
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        const result = await findContainerWithExecute(container).executeAsync(executeQuery, queryName, container, ...args.map(serializeArg));
        if (typeof result === 'string') {
            throw new Error(result);
        }
        if (!result) {
            return null;
        }
        if (Array.isArray(result)) {
            return Promise.all(result.map(({ selector }) => container.$(selector)));
        }
        return container.$(result.selector);
    };
}
function within(element) {
    return Object.keys(baseQueries).reduce((queries, queryName) => ({
        ...queries,
        [queryName]: createQuery(element, queryName),
    }), {});
}
/*
eslint-disable
@typescript-eslint/no-explicit-any,
@typescript-eslint/no-unsafe-argument
*/
function setupBrowser(browser) {
    const queries = {};
    Object.keys(baseQueries).forEach((key) => {
        const queryName = key;
        const query = async (...args) => {
            const body = await browser.$('body');
            return within(body)[queryName](...args);
        };
        // add query to response queries
        queries[queryName] = query;
        // add query to BrowserObject and Elements
        browser.addCommand(queryName, query);
        browser.addCommand(queryName, function (...args) {
            return within(this)[queryName](...args);
        }, true);
        // add chainable query to BrowserObject and Elements
        browser.addCommand(`${queryName}$`, query);
        browser.addCommand(`${queryName}$`, function (...args) {
            return within(this)[queryName](...args);
        }, true);
    });
    return queries;
}
/*
eslint-enable
@typescript-eslint/no-explicit-any,
@typescript-eslint/no-unsafe-argument
*/
function configure(config) {
    _config = config;
}
export * from './types';
export { within, setupBrowser, configure };
